#!/bin/bash
#
# Copyright (c) 2017 TimothÃ©e Feuillet
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# print and die
function die # (code, message...)
{
  code=$1
  shift
  echo 1>&2 "$@"
  exit $code
  exit 1
}
function diecv # (message...)
{
  die 1 $command_verb: "$@"
}

function debug_log # (message...)
{
  (( $VERBOSE )) && echo ' DD ' "$@"
}
function debug_logcv # (message...)
{
  debug_log $command_verb: "$@"
}



##
##  ENV CHECKS
##



function has # (command)
{
  hash "$1" &>/dev/null
}

function cmdcheck # (command)
{
  debug_log "checking for '$1'..."
  has "$1" || die 2 "command not found: '$1' is required by prig"
}

# check for required builtins
cmdcheck typeset
cmdcheck declare
cmdcheck compgen

# check for required commands
cmdcheck grep
cmdcheck tr
cmdcheck git

# check for alternatives (curl / wget, ...)
has wget && has_wget=true || has_wget=false
has wget && has_curl=true || has_curl=false
debug_log "has wget: ${has_wget}, has curl: ${has_curl}"




##
##  SETUP VARS FOR PRIG
##

# global options definition
gbl_opt_skip_unknown=false
help_gbl_opt_skip_unknown="Do not generate an error when a flag is not recognized"

gbl_opt_force_curl=false
help_gbl_opt_force_curl="Force the usage of curl when both wget and curl are available"

gbl_opt_prig_command_dir="./scripts/prig/"
help_gbl_opt_prig_command_dir="Indicate the folder that hold the external prig commands"

# command option definition


# misc var definition


# load the prig.conf file
[ -f ./prig.conf ] && { debug_log 'loading config file...' ; . prig.conf ; }



##
##  UTILITY FUNCTIONS FOR PRIG
##



function var_exists # (var-name)
{
  typeset -p $1 &>/dev/null
}



##
##  PRIG BUILTIN COMMANDS
##



cmd_opt_init_toto=
help_cmd_opt_init_toto="do stuff"

help_prig_cmd_init="Initialize prig in the current directory or the specified directory"
usage_prig_cmd_init="project-name [opt-project-directory]"
function prig_cmd_init # (project-name, project-directory='./')
{
  (( $# == 0 )) && diecv "missing project name. See help for more information."
  project_name="$1"
  (( $# == 2 )) && project_directory="$2" || project_directory="."

  debug_logcv "project-name: '$project_name'"
  debug_logcv "project-dir:  '$project_directory'"

  # TODO: finish that
}

# the help command
usage_prig_cmd_help="[opt-command-verb]"
help_prig_cmd_help="Print help of another command verb / list command verbs"
function prig_cmd_help # (command_verb?)
{
  if (( $# == 0 ))
  then
    # list everything
    echo 'listing all available commands:'

    # builtins
    builtin_commands="$(compgen -A function "prig_cmd_")"
    for cmd in $builtin_commands
    do
      echo '-------------------------------------------------------------------------------'
      cmd="${cmd:9}"
      cmd_help_print_options "$cmd"
    done

    # external commands
    ext_commands="$(compgen -A file "$gbl_opt_prig_command_dir/cmd_opt_")"
    for cmd in $ext_commands
    do
      echo '-------------------------------------------------------------------------------'
      file="$cmd"
      cmd="${cmd##*/}"
      cmd="${cmd:8}"
      debug_logcv "loading option file '$file' for command '$cmd'..."
      ( . $file; cmd_help_print_options "$cmd" )
    done
  else
    # list just one
    if ! has prig_cmd_"$1"
    then
      # try to load it
      cmd_opt_path="$gbl_opt_prig_command_dir/cmd_opt_$1"
      debug_logcv "$1 is not an internal command: trying to load its options from $cmd_opt_path"
      [ -e "$cmd_opt_path" ] && . "$cmd_opt_path" || diecv "Unable to find command '$1'"
    fi

    cmd_help_print_options "$1"
  fi
}
function cmd_help_print_options # (command_verb)
{
    echo "$1:"

    # print help message (if it exists)
    help_var="help_prig_cmd_$1"
    var_exists "$help_var" && echo "${!help_var}" && echo


    help_var_list="$(compgen -A variable "cmd_opt_$1")"
    help_fnc_list="$(compgen -A function "cmd_opt_$1")"

    # print usage (if it exists)
    usage_var="usage_prig_cmd_$1"

    if [ -z "$help_var_list$help_fnc_list" ]
    then
      if var_exists "$usage_var"
      then
        echo "  usage: $1 [--] ${!usage_var}"
      else
        echo "  usage: $1 [--]"
      fi
      echo
      return
    else
      var_exists "$usage_var" && echo "  usage: $1 [options] [--] ${!usage_var}" && echo
    fi

    # print options
    echo '  options:'
    echo "    most options can be negated by preprending 'no-' to them: --no-xyz-abc instead of --xyz-abc=false"
    echo
    echo

    # loop over variables
    for var in $help_var_list
    do
      optname="$(tr _ - <<<"${var:8}")"
      echo -n "  --${optname} (current value: '${!var}' )"
      help_var="help_$var"
      var_exists "$help_var" && echo -e ":\n    ${!help_var}" || echo
      echo
    done

    # loop over functions
    for fnc in $help_fnc_list
    do
      echo -n "  --${fnc:8}"
      help_var="help_$fnc"
      var_exists "$help_var" && echo -e ":\n    ${!help_var}" || echo
      echo
    done
}



##
##  PRIG OPTIONS
##
## prig format for options is:
## prig [prig gbl opts] command-word [command word opts]
##
## internally, options can either be functions or variables
##



help_gbl_opt_help="Print this message and exit"
function gbl_opt_help # ()
{
  echo 'options:'
  echo "  most options can be negated by preprending 'no-' to them: --no-xyz-abc instead of --xyz-abc=false"
  echo
  echo

  # loop over variables
  help_var_list="${!gbl_opt_@}"
  for var in $help_var_list
  do
    optname="$(tr _ - <<<"${var:8}")"
    echo -n "  --${optname} (current value: '${!var}' )"
    help_var="help_$var"
    var_exists "$help_var" && echo -e ":\n    ${!help_var}" || echo
    echo
  done

  # loop over functions
  help_fnc_list="$(compgen -A function 'gbl_opt_')"
  for fnc in $help_fnc_list
  do
    echo -n "  --${fnc:8}"
    help_var="help_$fnc"
    var_exists "$help_var" && echo -e ":\n    ${!help_var}" || echo
    echo
  done

  # exit
  exit
}

# global option parsing core
while (( $# > 0 )) && [ "${1:0:2}" = "--" ]
do
  option="${1#--}"
  option_value="${option#*=}"
  [ -z "$(grep <<<"$option" = )" ] && option_value=true
  option="$(tr - _ <<<"${option%%=*}")"
  [ "${option:0:3}" = "no_" ] &&
  {
    option_value=false
    option="${option#no_}"
  }

  has "gbl_opt_$option" && option_is_command=true || option_is_command=false
  var_exists "gbl_opt_$option" && option_is_var=true || option_is_var=false

  $option_is_var || $option_is_command || [ "$gbl_opt_skip_unknown" = true ] || die 3 "unknown option: $1"

  debug_log "gbl_opt_${option} => $option_value"

  $option_is_var && declare gbl_opt_${option}="$option_value"
  $option_is_command && gbl_opt_${option} "$option_value"

  shift
done

function run_command # (cmd, opts...?)
{
  (( $# == 0 )) && die 4 "no command provided..."

  # save the command verb and shift
  command_verb="$1"
  shift

  debug_log 'command verb:' $command_verb

  # check that the command exists
  if ! has prig_cmd_"$command_verb"
  then
    debug_log "searching for $command_verb in 'external' commands..."
    cmd_is_external=true
    cmd_opt_path="$gbl_opt_prig_command_dir/cmd_opt_$command_verb"
    cmd_script_path="$gbl_opt_prig_command_dir/cmd_$command_verb"

    if [ -e "$cmd_opt_path" ] && [ -e "$cmd_script_path" ]
    then
      debug_log "options for $command_verb have been located in $cmd_opt_path"
      debug_log "code for $command_verb have been located in $cmd_script_path"

      # load options, the script is loaded after that
      . "$cmd_opt_path"
    else
      die 5 "$command_verb: command verb does not exists. (has the folder been init / fixed / created with prig create or prig init or prig fix ?)"
    fi
  else
    cmd_is_external=false
  fi

  # command verb option parsing core
  while (( $# > 0 )) && [ "${1:0:2}" = "--" ] && [ "$1" != '--' ]
  do
    option="${1#--}"
    option_value="${option#*=}"
    [ -z "$(grep <<<"$option" = )" ] && option_value=true
    option="$(tr - _ <<<"${option%%=*}")"
    [ "${option:0:3}" = "no_" ] &&
    {
      option_value=false
      option="${option#no_}"
    }

    has "cmd_opt_${command_verb}_$option" && option_is_command=true || option_is_command=false
    var_exists "cmd_opt_${command_verb}_$option" && option_is_var=true || option_is_var=false

    $option_is_var || $option_is_command || [ "$gbl_opt_skip_unknown" = true ] || die 3 "unknown ${command_verb} option: $1"

    debug_log "cmd_opt_${command_verb}_${option} => $option_value"

    $option_is_var && declare cmd_opt_${command_verb}_${option}="$option_value"
    $option_is_command && cmd_opt_${command_verb}_${option} "$option_value"

    shift
  done

  # skip the -- terminator
  [ "$1" = '--' ] && shift

  debug_log "executing 'prig_cmd_$command_verb $@' ..."
  $cmd_is_external && . "$cmd_script_path"
  has prig_cmd_"$command_verb" || die 6 "$command_verb: malformed command verb script. Unable to run it. (missing entry point)"


  # call the command verb this is the last thing the prig core does
  prig_cmd_"$command_verb" "$@"
}

run_command "$@"
